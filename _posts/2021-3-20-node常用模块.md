---
layout: post
title: node常用模块记录
subtitle: 主要记录path,fs,event内置模块的使用
date: 2021-03-20
author:
header-img:
catalog: true
tags:
  - node.js
typora-root-url: ..
---

> 之前有过总结，但是总结的内容不够完善。

### path 模块

- `path.resolve` 方法用于将相对路径转为绝对路径。
  <br>

  > 它可以接受多个参数，依次表示所要进入的路径，直 到将最后一个参数转为绝对路径。如果根据参数无法得 到绝对路径，就以当前所在路径作为基准。除了根目 录，该方法的返回值都不带尾部的斜杠。

  ```node
  path.resolve("/foo/bar", "./baz");
  // '/foo/bar/baz'

  path.resolve("/foo/bar", "/tmp/file/");
  // '/tmp/file'

  path.resolve("wwwroot", "static_files/png/", "../gif/image.gif");
  // 如果当前目录是/home/myself/node，返回
  // /home/myself/node/wwwroot/static_files/  gif/image.gif
  ```

* `path.parse()` 方法可以返回路径各部分的信息。
  <br>

  ```node
  var myFilePath = "/someDir/someFile.json";
  path.parse(myFilePath).base;
  // "someFile.json"
  path.parse(myFilePath).name;
  // "someFile"
  path.parse(myFilePath).ext;
  // ".json"
  ```

### fs 模块

- `fs.writeFile(file, data[, options], callback);`在文件中写入内容；
  <br>

  > **_options 的参数 _**
  > flag：写入的方式。encoding：字符的编码；

  > **_flag_**
  > w 打开文件写入，默认值；
  > w+打开文件进行读写，如果不存在则创建文件；
  > r+ 打开文件进行读写，如果不存在那么抛出异常；
  > r 打开文件读取，读取时的默认值；
  > a 打开要写入的文件，将流放在文件末尾。如果不存 在则创建文件；
  > a+打开文件以进行读写，将流放在文件末尾。如果不 存在则创建文件

  ```node
  const fs = require("fs");
  const content = "hello";
  fs.writeFile("text3.txt", content, { flag: "w+" }, (err) => {
    console.log(err);
  });
  ```

* **fs.readFile(path[, options], callback)**：读取文件的内容；
  <br>

  ```node
  const fs = require("fs");

  fs.readFile("test.txt", { encoding: "utf-8" }, (err, data) => {
    if (err) throw err;
    console.log(data);
  });
  //如果不填写encoding，返回的结果是Buffer
  ```

  > options 还有另外一个参数 withFileTypes，默认为{withFileType：false}

  ```node
  const path = require("path");
  const fs = require("fs");
  /**
   * 创建一个读取文件的函数（递归遍历）
   */
  function readFolder(dirname) {
    fs.readdir(dirname, { withFileTypes: "true" }, (err, files) => {
      for (const file of files) {
        if (file.isDirectory()) {
          let newPath = path.resolve(dirname, file.name);
          readFolder(newPath);
        } else {
          console.log(file.name);
        }
      }
    });
  }
  readFolder("test");
  ```

  ```node
  //01.js
  const path = require("path");
  const fs = require("fs");
  /**
   * 文件的递归拷贝（将srcDir的文件全部拷贝destDir目录中）
   * @node .\01.js srcDir destDir
   * @process.argv--传给node的参数
   *
   */
  const srcDir = process.argv[2];
  const destDir = process.argv[3];

  const copy = (srcDir, destDir) => {
    if (!fs.existsSync(destDir)) fs.mkdirSync(destDir);
    fs.readdir(srcDir, { withFileTypes: "true" }, (err, files) => {
      if (err) throw err;
      //判断是否为目录
      files.forEach((file) => {
        if (file.isDirectory()) {
          const newSrcDir = path.resolve(srcDir, file.name);
          const newDestDir = path.resolve(destDir, file.name);
          copy(newSrcDir, newDestDir);
        } else {
          const srcFile = path.resolve(srcDir, file.name);
          const destFile = path.resolve(destDir, file.name);
          console.log(file.name, "文件开始拷贝");
          fs.copyFileSync(srcFile, destFile);
          console.log(file.name, "文件开始完成");
        }
      });
    });
  };
  copy(srcDir, destDir);
  ```

### event 模块

> `Node` 中的核心 `API` 都是基于异步事件驱动的

> 发出事件和监听事件都是通过 `EventEmitter` 类来完成的，它们都属
> 于 `events` 对象。

> emitter.on(eventName, listener)：监听事件，也可以使用 addListener；
> emitter.off(eventName, listener)：移除事件监听，也可以使用 removeListener；
> emitter.emit(eventName[, ...args])：发出事件，可以携带一些参数；

```node
const EventEmitter = require("events");
const bus = new EventEmitter();
function clickEvent(...args) {
  console.log("监听到click事件", args);
}
bus.on("click", clickEvent);

setTimeout(() => {
  bus.emit("click", 1);
  bus.off("click", clickEvent);
  bus.emit("click", 2);
}, 2000);

//打印 "监听到click事件 [ 1 ]"
```
