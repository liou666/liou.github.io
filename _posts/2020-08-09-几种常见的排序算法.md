---
layout: post
title: 几种常见的排序算法
subtitle:
date: 2020-08-09
author: liou
header-img:
catalog: true
tags:
  - 算法
typora-root-url: ..
---

# 数组、冒泡排序、插入排序、希尔排序、快速排序

数组:一组有序的数据,数据类型可以不一样。

数组的定义:2 种方式

1. 通过**构造函数**创建数组/实例化 Array 对象

语法: `var arrname=new Array();` 创建一个**空数组**。

语法: `var arrname=new Array(num);` 创建一个数组**长度为 num 的数组**；其中每一项都是 `undefined`。

语法: `var arrname=new Array(n1,n2...);` 创建由**传入参数组成的一个数组**。

2. 通过**字面量**的方式创建数组/使用[]方式

语法：`var array=[];` **创建空数组**

### 冒泡排序

外面的循环控制的是比较的轮数；里面的循环控制的是每一轮比较的次数。

1.从前往后 注意：i 取值的时候，不能取到`length-1`，否则 j 就会越界。

```javascript
var arr = [1, 9, 5, 2, 10, 3, 6, 4]; // 待排序数组
for (var i = 0; i < arr.length - 1; i++) {
  for (var j = i + 1; j < arr.length - 1 - i; j++) {
    if (arr[i] > arr[j]) {
      var temp = arr[j];
      arr[j] = arr[i];
      arr[i] = temp;
      //这里变量的交换也可以用数组的结构操作；
      // [arr[j],arr[j+1]]=[arr[j+1],arr[j]]
    }
  }
}
```

2.从后往前 先通过循环确定最后一位的最大值，然后继续往前确定数值。

```javascript
var arr = [1, 9, 5, 2, 10, 3, 6, 4]; // 待排序数组
for (var i = 0; i < arr.length - 1; i++) {
  for (var j = 0; j < arr.length - 1 - i; j++) {
    if (arr[j] > arr[j + 1]) {
      var temp = arr[j];
      arr[j] = arr[j + 1];
      arr[j + 1] = temp;
    }
  }
}
```

3.优化冒泡：设置一个标志位，减少不必要的循环

当原数组是，`arr = [1,2,4,3];`在经过第一轮冒泡排序之后，数组就变成了`arr = [1,2,3,4];`
此时，数组已经排序完成了，但是按上面的代码来看，数组还会继续排序，所以我们加一个标志位，如果某次循环完后，没有任何两数进行交换，就将标志位 设置为 true，表示排序完成，这样我们就可以减少不必要的排序，提高性能。

```javascript
var arr = [3, 4, 1, 2];
function bubbleSort(arr) {
  var max = arr.length - 1;
  for (var j = 0; j < max; j++) {
    // 声明一个变量，作为标志位
    var done = true;
    for (var i = 0; i < max - j; i++) {
      if (arr[i] > arr[i + 1]) {
        var temp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = temp;
        done = false;
      }
    }
    if (done) {
      break;
    }
  }
  return arr;
}
bubbleSort(arr);
```

### 插入排序 是冒泡排序的优化。

**实现原理**：通过构建有序数组对元素进行存储。
对于未排序的数组，在已排序的数组中从最后一个元素向第一个元素遍历，找到相应位置并插入。

```javascript
var arr = [89, 56, 100, 21, 87, 45, 1, 88]; // 待排序数组
// 按照从小到大的顺序排列
for (var i = 1; i < arr.length; i++) {
  let temp = arr[i];
  let j = i;
  while (arr[j - 1] > temp && j > 0) {
    arr[j] = arr[j - 1];
    j--;
  }
  arr[j] = temp;

  //当然也可以用for循环完成
  // for (var j = i; j > 0; --j) {
  //   if (arr[j - 1] > arr[j]) {
  //     [[arr[j - 1]], arr[j]] = [[arr[j]], arr[j - 1]];
  //   }
  // }
}
```

### 希尔排序

**实现原理**:

- 希尔排序主要通过对数据进行分组实现快速排序；
- 根据设定的增量`（gap）`将数据分为 `gap` 个组（组数等于 `gap`），再在每个分组中进行局部排序；

> 假如有数组有 10 个数据，第 1 个数据为黑色，增量为 5。那么第二个为黑色的数据 index=5，第 3 个数据为黑色的数据 index = 10（不存在）。所以黑色的数据每组只有 2 个，10 / 2 = 5 一共可分 5 组，即组数等于增量 gap。

- 排序之后，减小增量，继续分组，再次进行局部排序，直到增量 `gap=1` 为止。随后只需进行微调就可完成数组的排序；

> 希尔排序的效率和增量有直接关系，即使使用原稿中的增量`（arr.length/2）`效率都高于简单排序。

```javascript
//希尔排序
function shellSort(arr) {
  //1.获取数组的长度
  let length = arr.length;

  //2.初始化增量
  let gap = Math.floor(length / 2);

  //3.第一层循环：while循环(使gap不断减小)
  while (gap >= 1) {
    //4.第二层循环：以gap为增量，进行分组，对分组进行插入排序
    //重点为：将index = gap作为选中的第一个数据
    for (let i = gap; i < length; i++) {
      let temp = arr[i];
      let j = i;
      //5.第三层循环:寻找正确的插入位置
      while (arr[j - gap] > temp && j > gap - 1) {
        arr[j] = arr[j - gap];
        j -= gap;
      }
      //6.将j位置的元素设置为temp
      arr[j] = temp;
    }

    gap = Math.floor(gap / 2);
  }
}
```

#### 快速排序

**实现原理**:快速排序的核心思想是分而治之，先选出一个数据，将比其小的数据都放在它的左边，将比它大的数据都放在它的右边。这个数据称为枢纽

> 平均时间复杂度为:N(n\*logn) 效率最高

```javascript
var quickSort = function (arr) {
  if (arr.length <= 1) {
    return arr;
  }
  var pivotIndex = Math.floor(arr.length / 2);
  var pivot = arr.splice(pivotIndex, 1)[0];
  var left = [];
  var right = [];
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat([pivot], quickSort(right));
  //或者可以写成
  return [...qSort(left), ...[base], ...qSort(right)];
};
```
